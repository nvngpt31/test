
display a systems vital stats and highest CPU utilizing process:

root@www:~ # top -b -n 1 | head -n 8

------------------------------------------

Load average:
Run top

load average is shown in 1 min, 5 min and 15 min average 

It should be beween 1 - 2 (or less ) for a regular server

It may go between 3 - 4  for database sever

If the number is more then CPU need to be checked

-------------

top -n ( just run one time and exit for script purpose)
------------------
To list the process by memory usage-
Run top and then pres M ( in caps)
  ------------------------------------------
Check the free memory on linux:
To check free ram run "free -m" 
and look at "-/+ buffers/cache" column that says "free". It is in megabytes:
$ free -m
             total       used       free     shared    buffers     cached
Mem:          1504       1491         13          0         91        764
-/+ buffers/cache:        635        869
Swap:         2047          6       2041
$

If you don't know how to read the numbers, you'll think the ram is 99% full when it's really just 42%. 

___________________________________________

Check for zombie process ===>  <defunc> 

------------------------------------------


sar -u   ( CPU utilization )

_--------------------------------------

SWAP:

vmstat 

vmstat 3 2  ( Interval, how many times )

sar -r 2 10  ( check swap utilization using sar)

---------------------------------------

IO check:

iostat -x 

If wait is too high then it is a isssue
-----------------------------------------
Network check:

#netstat -i

------------------------------------------
NICE  ( -5) highest priority
        19  lowest  priority

system processes will run at (-5)
-------------------------------------------- 

sar can go back in time and check the utilization

----------------------------------------------

How to read the output of vmstat:

By default, vmstat and iostat produce just one report showing the average values of various counters since the server was started, which is not very useful. However, you can give both tools an interval argument. (The first line shows the statistics since the system was started; you can just ignore this line.)



Let’s look at an example of vmstat first. To make it print out a new report every five seconds, use the following command:
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu------
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 282824  16220 168068    0    0    55    13 1004   26  1  1 98  0  0
 0  0      0 282824  16220 168068    0    0     0     0 1011   17  0  0 100  0  0
 0  0      0 282824  16240 168076    0    0     2    26 1008   34  0  1 99  0  0
 0  0      0 282824  16248 168076    0    0     0     8 1013   19  0  0 100  0  0





Below are some general tips, which you can use while interpreting the output -

•The run queue (r) is a queue of processes that are ready to run but must wait for their turn on a CPU; a run queue of 5 means that 5 processes are currently waiting to execute. When the CPU is pegged at 100% utilization, the severity of the CPU starvation won’t be reflected in the percentage of CPU utilization, but the run queue (r) will clearly show the impact.

•Number of processes in uninterruptible sleep (b) can be used to identify the CPU power. If the value is constantly greater than zero then you may not have enough CPU power. Find out most CPU consuming processes and SQL statements. You can use ps command to list out most CPU consuming processes.

•Amount of memory swapped in from disk (si) and Amount of memory swapped to disk (so) can be used to identify the memory bottleneck. If the value is constantly greater than zero, then it is an indication that you have a memory issue. You can use ps command to list out most memory consuming processes.We like to see si and so at 0 most of the time, and we definitely don’t like to see more than 10 blocks per second. Bursts are also bad.

•These columns show how many blocks per second are read in from (bi) and written out to (bo) block devices. This usually reflects disk I/O.

•Time spent running non-kernel code (us) is high (ie. above the normal usage) there is a possbility that some of the user intiated processes are consuming high CPU, use ps to list ouf the most CPU consuming processes.

•Time spent waiting for IO (wa) is high then there is an issue in the disk storage subsystem and you will have to identify the sources of I/O contention using iostat.


----------------------------------------------------


